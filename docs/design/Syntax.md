# Hamler Syntax Specification

The specification is derived from [Haskell Syntax Reference](https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010)

## Modules

```haskell
module ModuleName where
module ModuleName (export1, export2) where
```

## Imports

```haskell
import Module
import Module (export1, export2)
import Module hiding (export1, export2)
import Module as M
```

## Notational Conventions

These notational conventions are used for presenting syntax:

```
[Pattern]   optional
{Pattern}   zero or more repetitions
(Pattern)   grouping
Pat1 | Pat2 choice
Pat⟨pat′⟩    difference—elements generated by pat except those generated by pat′
fibonacci   terminal syntax in typewriter font
```

BNF-like syntax is used throughout, with productions having the form:

```
NonTerminal ->	Alt1 | Alt2 | … | Altn
```

## Lexical Syntax

```
Program		->  { Lexeme | Whitespace }
Lexeme		->  Qvarid | Qconid | Qvarsym | Qconsym | Literal | Special | ReservedOp | Keyword
Literal		->  Integer | Float | Char | String
Special		->	( | ) | , | ; | [ | ] | ` | { | }

Whitespace	->	Whitestuff {Whitestuff}
Whitestuff	->	Whitechar | Comment | NComment
Whitechar		->	Newline | vertab | space | tab | uniWhite
Newline			->	return linefeed | return | linefeed | formfeed
return			->	'\r' "a carriage return"
linefeed		->	'\n' "a line feed"
vertab			->	'\v' "a vertical tab"
formfeed		->	'\f' "a form feed"
space				->	'\s' "a space"
tab					->	'\t' (a horizontal tab)
uniWhite		->	"any Unicode character defined as whitespace"
	
Comment			->	Dashes [ any⟨symbol⟩ {any} ] newline
dashes			->	-- {-}

NComment		->	Opencom ANY seq {NComment ANY seq} Closecom
Opencom			->	{-
Closecom		->	-}
ANY seq			->	{ANY }⟨{ANY } ( Opencom | Closecom ) {ANY }⟩
ANY					->	Graphic | Whitechar
any					->	Graphic | space | tab
Graphic			->	Small | Large | Symbol | Digit | Special | " | '

Small				->	AscSmall | UniSmall | _
AscSmall		->	a | b | … | z
UniSmall		->	"any Unicode lowercase letter"
Large				->	AscLarge | UniLarge
AscLarge		->	A | B | … | Z
UniLarge		->	"any uppercase or titlecase Unicode letter"
Symbol			->	AscSymbol | UniSymbol⟨Special | _ | " | '⟩

AscSymbol		->	! | # | $ | % | & | ⋆ | + | . | / | < | = | > | ? | @ 
							|	\ | ^ | | | - | ~ | :
UniSymbol		->	"any Unicode symbol or punctuation"

Digit				->	AscDigit | UniDigit
AscDigit		->	0 | 1 | … | 9
UniDigit		->	"any Unicode decimal digit?
Octit				->	0 | 1 | … | 7
Hexit				->	Digit | A | … | F | a | … | f

Varid				->	(Small {Small | Large | Digit})⟨Keyword⟩
Vonid				->	Large {Small | Large | Digit}
Keyword			-> and | andalso | begin | case | do | else | end | export | if
             | fun | import | in | let | of | module | not | orelse | then | type 
             | _

Varsym			->	( symbol⟨:⟩ {symbol} )⟨Reservedop | Dashes⟩
Consym			->	( : {symbol})⟨Reservedop⟩
Reservedop	->	.. | : | :: | = | \ | | | <- | -> |  @ | ~ | =>

varid	    	    (variables)
conid	    	    (constructors)
tyvar	->	varid	    (type variables)
tycon	->	conid	    (type constructors)
Modid	->	{Conid .} Conid	    (modules)

Qvarid	->	[ Modid . ] Varid
Qconid	->	[ Modid . ] Conid
qtycon	->	[ Modid . ] tycon
qvarsym	->	[ Modid . ] varsym
qconsym	->	[ Modid . ] consym

Integer		->	Decimal | 0o Octal | 0O Octal | 0x Hexadecimal | 0X Hexadecimal
Float			->	Decimal . Decimal [Exponent] | Decimal Exponent
Exponent	->	(e | E) [+ | -] Decimal
Decimal			->	Digit{Digit}
Octal				->	Octit{Octit}
Hexadecimal	->	Hexit{Hexit}

Char			->	' (graphic⟨' | \⟩ | space | escape⟨\&⟩) '
String		->	" {graphic⟨" | \⟩ | space | escape | gap} "
Escape		->	\ ( Charesc | Ascii | Decimal | o Octal | x Hexadecimal )
Charesc		->	a | b | f | n | r | t | v | \ | " | ' | &
Ascii			->	^cntrl | NUL | SOH | STX | ETX | EOT | ENQ | ACK
						|	BEL | BS | HT | LF | VT | FF | CR | SO | SI | DLE
						|	DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN
						|	EM | SUB | ESC | FS | GS | RS | US | SP | DEL
Cntrl	->	AscLarge | @ | [ | \ | ] | ^ | _
Gap	->	\ Whitechar {Whitechar} \


```

```
		\n	newline
		\r	carriage-return
		\t	tab
		\b	backspace
		\f	form feed
```

Tokens:

- Identifiers
- Keywords
- Numbers
- Strings
- Punctuators

## Layout

Yes: Do it multi-pass. First tokenize, including the amount of following indentation in the newline-tokens, then replace newlines with explicit nesting tokens, then parse the resulting token sequence. (While you're at it, consider adding explicit nesting to your grammar, like Haskell's {;})

indent-sensive parser is required.

## Context-Free Syntax

- Module
- Types
- Functions
- Expressions

```
Module		->	module Modid [Exports] Body | Body
Body			->	{ Impdecls ; Topdecls } | { Impdecls } |	{ Topdecls }
 
Exports		->	( Export1 , … , Exportn [ , ] )	    (n ≥ 0)

??: xyz
Export		->	Qvar | Qtycon [(..) | ( cname1 , … , cnamen )]	    (n ≥ 0)


Impdecls	->	Impdecl1 ; … ; Impdecln	    (n ≥ 1)
 

 
Impdecl		->	import Modid [as Modid] [Impspec] | (empty declaration)
Impspec		->	( import1 , … , importn [ , ] )	    (n ≥ 0)
 
import	→	var
|	tycon [ (..) | ( cname1 , … , cnamen )]	    (n ≥ 0)
|	tycls [(..) | ( var1 , … , varn )]	    (n ≥ 0)
cname	→	var | con
 
topdecls	→	topdecl1 ; … ; topdecln	    (n ≥ 0)
topdecl	→	type simpletype = type
|	data [context =>] simpletype [= constrs] [deriving]
|	newtype [context =>] simpletype = newconstr [deriving]
|	class [scontext =>] tycls tyvar [where cdecls]
|	instance [scontext =>] qtycls inst [where idecls]
|	default (type1 , … , typen)	    (n ≥ 0)
|	foreign fdecl
|	decl
 
decls	→	{ decl1 ; … ; decln }	    (n ≥ 0)
decl	→	gendecl
|	(funlhs | pat) rhs
 
cdecls	→	{ cdecl1 ; … ; cdecln }	    (n ≥ 0)
cdecl	→	gendecl
|	(funlhs | var) rhs
 
idecls	→	{ idecl1 ; … ; idecln }	    (n ≥ 0)
idecl	→	(funlhs | var) rhs
|		    (empty)
 
gendecl	→	vars :: [context =>] type	    (type signature)
|	fixity [integer] ops	    (fixity declaration)
|		    (empty declaration)
 
ops	→	op1 , … , opn	    (n ≥ 1)
vars	→	var1 , …, varn	    (n ≥ 1)
fixity	→	infixl | infixr | infix
 
type	→	btype [-> type]	    (function type)
 
btype	→	[btype] atype	    (type application)
 
atype	→	gtycon
|	tyvar
|	( type1 , … , typek )	    (tuple type, k ≥ 2)
|	[ type ]	    (list type)
|	( type )	    (parenthesized constructor)
 
gtycon	→	qtycon
|	()	    (unit type)
|	[]	    (list constructor)
|	(->)	    (function constructor)
|	(,{,})	    (tupling constructors)
 
context	→	class
|	( class1 , … , classn )	    (n ≥ 0)
class	→	qtycls tyvar
|	qtycls ( tyvar atype1 … atypen )	    (n ≥ 1)
scontext	→	simpleclass
|	( simpleclass1 , … , simpleclassn )	    (n ≥ 0)
simpleclass	→	qtycls tyvar
 
simpletype	→	tycon tyvar1 … tyvark	    (k ≥ 0)
constrs	→	constr1 | … | constrn	    (n ≥ 1)
constr	→	con [!] atype1 … [!] atypek	    (arity con  =  k, k ≥ 0)
|	(btype | ! atype) conop (btype | ! atype)	    (infix conop)
|	con { fielddecl1 , … , fielddecln }	    (n ≥ 0)
newconstr	→	con atype
|	con { var :: type }
fielddecl	→	vars :: (type | ! atype)
deriving	→	deriving (dclass | (dclass1, … , dclassn))	    (n ≥ 0)
dclass	→	qtycls
 
inst	→	gtycon
|	( gtycon tyvar1 … tyvark )	    (k ≥ 0, tyvars distinct)
|	( tyvar1 , … , tyvark )	    (k ≥ 2, tyvars distinct)
|	[ tyvar ]
|	( tyvar1 -> tyvar2 )	    tyvar1 and tyvar2 distinct
 
fdecl	→	import callconv [safety] impent var :: ftype	    (define variable)
|	export callconv expent var :: ftype	    (expose variable)
callconv	→	ccall | stdcall | cplusplus	    (calling convention)
|	jvm | dotnet
|	 system-specific calling conventions
impent	→	[string]	    (see Section 8.5.1)
expent	→	[string]	    (see Section 8.5.1)
safety	→	unsafe | safe
 
ftype	→	frtype
|	fatype  →  ftype
frtype	→	fatype
|	()
fatype	→	qtycon atype1 … atypek	    (k  ≥  0)
 
funlhs	→	var apat { apat }
|	pat varop pat
|	( funlhs ) apat { apat }
 
rhs	→	= exp [where decls]
|	gdrhs [where decls]
 
gdrhs	→	guards = exp [gdrhs]
 
guards	→	| guard1, …, guardn	    (n ≥ 1)
guard	→	pat <- infixexp	    (pattern guard)
|	let decls	    (local declaration)
|	infixexp	    (boolean guard)
 
exp	→	infixexp :: [context =>] type	    (expression type signature)
|	infixexp
 
infixexp	→	lexp qop infixexp	    (infix operator application)
|	- infixexp	    (prefix negation)
|	lexp
 
lexp	→	\ apat1 … apatn -> exp	    (lambda abstraction, n ≥ 1)
|	let decls in exp	    (let expression)
|	if exp [;] then exp [;] else exp	    (conditional)
|	case exp of { alts }	    (case expression)
|	do { stmts }	    (do expression)
|	fexp
fexp	→	[fexp] aexp	    (function application)
 
aexp	→	qvar	    (variable)
|	gcon	    (general constructor)
|	literal
|	( exp )	    (parenthesized expression)
|	( exp1 , … , expk )	    (tuple, k ≥ 2)
|	[ exp1 , … , expk ]	    (list, k ≥ 1)
|	[ exp1 [, exp2] .. [exp3] ]	    (arithmetic sequence)
|	[ exp | qual1 , … , qualn ]	    (list comprehension, n ≥ 1)
|	( infixexp qop )	    (left section)
|	( qop⟨-⟩ infixexp )	    (right section)
|	qcon { fbind1 , … , fbindn }	    (labeled construction, n ≥ 0)
|	aexp⟨qcon⟩ { fbind1 , … , fbindn }	    (labeled update, n  ≥  1)
 
qual	→	pat <- exp	    (generator)
|	let decls	    (local declaration)
|	exp	    (guard)
 
alts	→	alt1 ; … ; altn	    (n ≥ 1)
alt	→	pat -> exp [where decls]
|	pat gdpat [where decls]
|		    (empty alternative)
 
gdpat	→	guards -> exp [ gdpat ]
 
stmts	→	stmt1 … stmtn exp [;]	    (n ≥ 0)
stmt	→	exp ;
|	pat <- exp ;
|	let decls ;
|	;	    (empty statement)
 
fbind	→	qvar = exp
 
pat	→	lpat qconop pat	    (infix constructor)
|	lpat
 
lpat	→	apat
|	- (integer | float)	    (negative literal)
|	gcon apat1 … apatk	    (arity gcon  =  k, k ≥ 1)
 
apat	→	var [ @ apat]	    (as pattern)
|	gcon	    (arity gcon  =  0)
|	qcon { fpat1 , … , fpatk }	    (labeled pattern, k ≥ 0)
|	literal
|	_	    (wildcard)
|	( pat )	    (parenthesized pattern)
|	( pat1 , … , patk )	    (tuple pattern, k ≥ 2)
|	[ pat1 , … , patk ]	    (list pattern, k ≥ 1)
|	~ apat	    (irrefutable pattern)
 
fpat	→	qvar = pat
 
gcon	→	()
|	[]
|	(,{,})
|	qcon
 
var	→	varid | ( varsym )	    (variable)
qvar	→	qvarid | ( qvarsym )	    (qualified variable)
con	→	conid | ( consym )	    (constructor)
qcon	→	qconid | ( gconsym )	    (qualified constructor)
varop	→	varsym | `  varid `	    (variable operator)
qvarop	→	qvarsym | `  qvarid `	    (qualified variable operator)
conop	→	consym | `  conid `	    (constructor operator)
qconop	→	gconsym | `  qconid `	    (qualified constructor operator)
op	→	varop | conop	    (operator)
qop	→	qvarop | qconop	    (qualified operator)
gconsym	→	: | qconsym
```

## References

- http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf

