-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Process
-- Copyright   :  (c) 2020 EMQ Technologies Co., Ltd.
-- License     :  BSD-style (see the LICENSE file)
--
-- Maintainer  :  Feng Lee, feng@emqx.io
--                Yang M, yangm@emqx.io
-- Stability   :  experimental
-- Portability :  portable
--
-- The Process module.
--
-----------------------------------------------------------------------------
module Control.Process
  ( module Types
  , Module
  , Node
  , Process
  , node
  , self
  , selfPid
  , selfNode
  , spawn
  , send
  , receive
  , receiveAfter
    -- * Registered Processes
  , register
  , registered
  , whereis
    -- * Linking and Monitoring
  , link
  , unlink
  , monitor
  , isProcessAlive
  , trapExit
    -- * Process Termination
  , exit
  , kill
  ) where

import Control.Monad
import Data.Maybe (Maybe)
import Data.Pid (Pid)
import Data.Ref (Reference)
import Data.Unit (Unit)
import Foreign (ffiIO0, ffiIO1, ffiIO2)
import Control.Process.Types
  ( From
  , ExitReason(..)
  ) as Types

type Module = Atom

-- An Erlang Node.
type Node = Atom

-- An Alias of IO.
type Process = IO

-- String to Node
foreign import node :: String -> Node

-- An alias of selfPid.
self :: Process Pid
self = selfPid

-- Return the Pid of calling process.
foreign import selfPid :: Process Pid

-- Return the name of this node.
foreign import selfNode :: Process Node

-- Spawn a Process.
foreign import spawn ::forall a b. (a -> IO b) -> a -> Process Pid

-- Send a message to a Process.
foreign import send :: forall a. Pid -> a -> Process a

infixr 1 sendc as !
--- send pid1 ! send pid2 ! send pid3 ! send pid4  ! pure message
sendc :: forall a. (a -> Process a) -> Process a -> Process a
sendc f a = a >>= f

foreign import receive :: forall a. Process a

foreign import receiveAfter :: forall a. Integer -> Process a

-- foreign import receiveScanlMatch :: forall a b.(a -> Process b) ->Process b

-----------------------------------------------------------------------------
-- | Registered Processes
-----------------------------------------------------------------------------

register :: Atom -> Pid -> Process ()
register = ffiIO2 :erlang :register

registered :: Process [Atom]
registered = ffiIO0 :erlang :registered

foreign import whereis :: Atom -> Process (Maybe Pid)

-----------------------------------------------------------------------------
-- | Linking and Monitoring
-----------------------------------------------------------------------------

link :: Pid -> Process ()
link = ffiIO1 :erlang :link

unlink :: Pid -> Process ()
unlink = ffiIO1 :erlang :unlink

foreign import monitor :: Pid -> Process Reference

isProcessAlive :: Pid -> Process Boolean
isProcessAlive = ffiIO1 :erlang :is_process_alive

foreign import trapExit :: Boolean -> Process Boolean

-----------------------------------------------------------------------------
-- | Process Termination
-----------------------------------------------------------------------------

exit :: forall r. r -> Process ()
exit = ffiIO1 :erlang :exit

foreign import kill :: Pid -> Process ()

